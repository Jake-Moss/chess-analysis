#+TITLE: Presentation - Positional analysis of chess games
#+startup: beamer
#+LaTeX_CLASS: beamer
#+latex_header: \usepackage{xskak, chessboard}
#+LaTeX_CLASS_OPTIONS: [presentation, 8pt]
#+options: H:2 toc:nil
* Plot analysis
** Heat map grid
[[file:Images/_HEATMAP_Queen_Rook_Bishop_Knight_Pawn_WHITE_ELO_FISC.png]]
** Head map single
[[file:Images/_HEATMAP_Knight_FISC.png]]
** Histogram grid
[[file:Images/_HIST_Queen_Rook_Bishop_Knight_Pawn_WHITE_ELO_FISC.png]]
** Histogram single
[[file:Images/_HIST_Pawn_FISC.png]]
** Date based plots
[[file:Images/_HEATMAP_Queen_Rook_Bishop_Knight_Pawn_BLACK_DATE_TOURNEMENTS.png]]
** Date based plots
[[file:Images/_HIST_Queen_Rook_Bishop_Knight_Pawn_BLACK_DATE_TOURNEMENTS.png]]

* Difficulties and issues
** Pawn capture on 8th rank
[[file:Images/Pawn on 8th rank.png]]
** Pawn capture on 8th rank
#+begin_quote
3.7e) When  a  pawn  reaches  the  rank  furthest  from  its  starting  position  it  must  be  exchanged  as  part  of  the  same  move  on  the  same  square  for  a  new queen,  rook,  bishop  or  knight  of  the  same  colour.  The  player’s  choice  is  not  restricted  to  pieces  that  have  been  captured  previously.  This  exchange  of  a  pawn  for  another  piece  is  called ‘promotion’ and the effect of the new piece is immediate.
#+end_quote
[[https://www.fide.com/FIDE/handbook/LawsOfChess.pdf][Source: FIDE Laws of chess]]
** Bug location
#+begin_src python :export code :results none
def piece_delta(board: chess.Board, count: int, piece_count: Dict[int, int],
                colour: bool) -> Tuple[int, int, int]:
    piece_position = (0, 0, 0)
    for key, value in piece_count.items():
        current_count = bin(board.pieces_mask(key, colour)).count('1')
        if current_count < value: # Detects lost based on previous state
            piece_position = (key, uci_to_1d_array_index(board.peek().uci()), count)
            piece_count[key] = current_count # Modify by object-reference
            break
        elif current_count > value: # Accounts for promotion
            piece_count[key] = current_count # Modify by object-reference
            piece_count[chess.PAWN] = bin(board.pieces_mask(chess.PAWN, colour)).count('1')  # Account for pawn count change
            break
    return piece_position # piece id, position, count
#+end_src
** Bug location
:PROPERTIES:
:BEAMER_envargs: [t]
:END:
#+begin_src python exports: code results: none
board.pieces_mask(chess.PAWN, chess.BLACK)
#+end_src
*** Data structure
:PROPERTIES:
:BEAMER_col: 0.45
:BEAMER_env: block
:END:
| / | < |   |   |   |   |   |   | > |
|---+---+---+---+---+---+---+---+---|
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 |
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
|---+---+---+---+---+---+---+---+---|
*** Board
:PROPERTIES:
:BEAMER_col: 0.45
:BEAMER_env: block
:END:
#+begin_export latex
\setchessboard{boardfontsize=15pt}
\newchessgame
\showonly{p}
\chessboard[hideall,showpieces={p},showmover=false]
#+end_export
** Culprit
:PROPERTIES:
:BEAMER_envargs: [t]
:END:
*** Inital state
:PROPERTIES:
:BEAMER_col: 0.45
:BEAMER_env: block
:END:
[[file:Images/Pawn capture 8th rank.png]]
*** Final state
:PROPERTIES:
:BEAMER_col: 0.45
:BEAMER_env: block
:END:
[[file:Images/pawn promote 8th rank.png]]
** Timezones
[[file:Images/Gregorian-calendar-large.jpg]]
[[https://www.familytreemagazine.com/wp-content/uploads/2018/10/Gregorian-calendar-large.jpg?x73159]]
* Performance
** Performance
:PROPERTIES:
:BEAMER_envargs: [t]
:END:
*** FISC
:PROPERTIES:
:BEAMER_col: 0.45
:BEAMER_env: block
:END:
#+begin_src bash :exports code
$ wc -l *
    3502985 ficsgamesdb_2000.pgn
    ...
   11126076 ficsgamesdb_2020.pgn
  452107755 total

$ du -h ./
17G

$ ls | wc -l
21
#+end_src

*** Tournements
:PROPERTIES:
:BEAMER_col: 0.45
:BEAMER_env: block
:END:
#+begin_src bash :exports code
$ wc -l *
     178 Aachen1868.pgn
     ...
    1196 Zurich2015.pgn
 1786360 total

$ du -h ./
64M

$ ls | wc -l
1059
#+end_src

** Profiling
[[file:Images/Profiling.png]]
* Improvements
** Evaluation of positions using engines
*** [[https://www.scitepress.org/papers/2018/65355/65355.pdf][Learning to Evaluate Chess Positions with Deep Neural Networks and Limited Look ahead]]
#+begin_quote
...We collect around 3,000,000 different chess positions played by highly skilled chess players and label them with the evaluation function of Stockfish, one of the strongest existing chess engines. We create 4 different datasets from scratch that are used for different classification and regression experiments. ...
#+end_quote
[[doi:10.5220/0006535502760283]]
** Popular chess engines
- Stockfish
  + Strongest currently
  + Traditional
  + FOSS
- Leela Chess Zero
  + Self-taught through reinforcement learning and repeated self-play
  + FOSS
- AlphaZero
  + First engine to use reinforcement learning and self-play
  + Propriety
- Komodo
  + Propriety
  + Used by ~Chess.com~ for it's celebrity bots
* Failed plots
** KDE plots
[[file:Images/failed kde.png]]

* Final words
** Final words
Source code: [[https://github.com/Jake-Moss/chess-analysis]]

Additions:
[[file:Images/Additions.png]]
Deletions:
[[file:Images/Deletions.png]]

Broke git once on Mar 7, 2021.

Everything was written in Emacs.
